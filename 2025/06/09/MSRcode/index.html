<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MSR编码子包化率的指数下界 | 鱼鱼煊</title><meta name="author" content="煊"><meta name="copyright" content="煊"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="好的，这篇论文 “An Exponential Lower Bound on the Sub-Packetization of MSR Codes” (MSR编码子包化率的指数下界) 是一篇在编码理论和分布式存储领域具有重要影响的论文。它解决了一个关于MSR码效率的核心开放问题。 我将分两部分为您解释：  论文的主要内容和贡献：用通俗的语言解释论文解决了什么问题，以及其结果的意义。 主要结果的推导">
<meta property="og:type" content="article">
<meta property="og:title" content="MSR编码子包化率的指数下界">
<meta property="og:url" content="http://example.com/2025/06/09/MSRcode/index.html">
<meta property="og:site_name" content="鱼鱼煊">
<meta property="og:description" content="好的，这篇论文 “An Exponential Lower Bound on the Sub-Packetization of MSR Codes” (MSR编码子包化率的指数下界) 是一篇在编码理论和分布式存储领域具有重要影响的论文。它解决了一个关于MSR码效率的核心开放问题。 我将分两部分为您解释：  论文的主要内容和贡献：用通俗的语言解释论文解决了什么问题，以及其结果的意义。 主要结果的推导">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-06-09T06:28:07.244Z">
<meta property="article:modified_time" content="2025-06-09T07:06:57.470Z">
<meta property="article:author" content="煊">
<meta property="article:tag" content="编码理论">
<meta property="article:tag" content="MSR">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MSR编码子包化率的指数下界",
  "url": "http://example.com/2025/06/09/MSRcode/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-06-09T06:28:07.244Z",
  "dateModified": "2025-06-09T07:06:57.470Z",
  "author": [
    {
      "@type": "Person",
      "name": "煊",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/06/09/MSRcode/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MSR编码子包化率的指数下界',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">鱼鱼煊</span></a><a class="nav-page-title" href="/"><span class="site-name">MSR编码子包化率的指数下界</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">MSR编码子包化率的指数下界</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-09T06:28:07.244Z" title="发表于 2025-06-09 14:28:07">2025-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-09T07:06:57.470Z" title="更新于 2025-06-09 15:06:57">2025-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/">study</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>好的，这篇论文 <strong>“An Exponential Lower Bound on the Sub-Packetization of MSR Codes” (MSR编码子包化率的指数下界)</strong> 是一篇在编码理论和分布式存储领域具有重要影响的论文。它解决了一个关于MSR码效率的核心开放问题。</p>
<p>我将分两部分为您解释：</p>
<ol>
<li><strong>论文的主要内容和贡献</strong>：用通俗的语言解释论文解决了什么问题，以及其结果的意义。</li>
<li><strong>主要结果的推导过程</strong>：深入技术细节，解释核心定理是如何通过一系列数学定义和引理推导出来的，并给出关键的数学公式。</li>
</ol>
<hr>
<h3 id="第一部分：论文主要内容和贡献"><a href="#第一部分：论文主要内容和贡献" class="headerlink" title="第一部分：论文主要内容和贡献"></a>第一部分：论文主要内容和贡献</h3><h4 id="1-背景：分布式存储系统中的“修复”难题"><a href="#1-背景：分布式存储系统中的“修复”难题" class="headerlink" title="1. 背景：分布式存储系统中的“修复”难题"></a>1. 背景：分布式存储系统中的“修复”难题</h4><ul>
<li><strong>分布式存储系统 (DSS)</strong>：想象一下，为了数据安全，我们不把一个大文件（比如一部电影）存在一台服务器上，而是把它分成 <code>k</code> 块，然后通过编码生成 <code>n</code> 块（<code>n &gt; k</code>），分别存在 <code>n</code> 台不同的服务器上。这 <code>n</code> 台服务器就是一个分布式存储系统。</li>
<li><strong>MDS 码</strong>：这是一种最优的编码方式。它的特性是，只要 <code>n</code> 台服务器中任意 <code>k</code> 台是好的，我们就能恢复出全部原始数据。这提供了极好的容错性，可以抵御 <code>n-k</code> 台服务器同时损坏的“灾难性”故障。</li>
<li><strong>子包化率 (Sub-Packetization, <code>l</code>)</strong>：在实际应用中，每个服务器上存的不是一个单一的数字，而是一个向量，即一“包”数据。这个向量的长度 <code>l</code> 就是子包化率。它代表了数据切分的精细程度。</li>
<li><strong>修复问题</strong>：在大型数据中心，服务器宕机是常态。最常见的故障是<strong>单节点故障</strong>。当一台服务器坏掉时，我们需要从其他好的服务器上读取一些数据，来“修复”或“再生”坏掉的那台服务器上的数据。</li>
<li><strong>MSR 码 (Minimum Storage Regenerating)</strong>：这是一种非常理想的编码。它既是MDS码（容错性最好），又能在修复单个故障节点时，<strong>下载的数据量（修复带宽）达到理论上的最小值</strong>。</li>
</ul>
<h4 id="2-核心问题：MSR码的代价是什么？"><a href="#2-核心问题：MSR码的代价是什么？" class="headerlink" title="2. 核心问题：MSR码的代价是什么？"></a>2. 核心问题：MSR码的代价是什么？</h4><p>之前的研究人员设计出了多种MSR码的构造方法，但他们发现一个共同的问题：所有已知的MSR码都要求一个非常大的子包化率 <code>l</code>，<code>l</code> 的值随着数据块数 <code>k</code> 的增长呈<strong>指数级增长</strong>（例如 <code>l ≥ r^(k/r)</code>，其中 <code>r=n-k</code> 是冗余度）。</p>
<p><strong>为什么大的 <code>l</code> 是个问题？</strong></p>
<ul>
<li><strong>计算和元数据复杂</strong>：<code>l</code> 越大，每个节点上数据的内部结构越复杂，编码、解码和修复的计算开销变大，管理这些数据的元数据也变得非常复杂。</li>
<li><strong>设计空间受限</strong>：<code>l</code> 太大可能会限制系统的总节点数 <code>n</code>。</li>
</ul>
<p>这就引出了一个核心问题：<strong>MSR码的巨大子包化率 <code>l</code> 是现有构造方法的缺陷，还是MSR码本身固有的、不可避免的代价？</strong></p>
<h4 id="3-论文的主要贡献"><a href="#3-论文的主要贡献" class="headerlink" title="3. 论文的主要贡献"></a>3. 论文的主要贡献</h4><p>这篇论文给出了一个决定性的答案：<strong>巨大的子包化率是MSR码固有的代价</strong>。</p>
<p>论文的主要结果（非正式表述）是：</p>
<blockquote>
<p>对于任何一个MSR码，其子包化率 <code>l</code> 必须满足一个指数下界：<br><strong>l &gt; exp(Ω(k&#x2F;r))</strong></p>
</blockquote>
<p>这个结果非常重要，因为它：</p>
<ol>
<li><strong>证明了指数级的子包化率是不可避免的</strong>：它告诉我们，追求MSR码的极致修复效率，必然要付出子包化率指数增长的代价。我们无法设计出兼具MDS特性、最小修复带宽和低子包化率（如多项式级别）的编码。</li>
<li><strong>几乎匹配了已知构造的上界</strong>：已知最好的MSR码构造给出的子包化率是 <code>r^O(k/r)</code>，这与论文证明的下界 <code>exp(Ω(k/r))</code> 在指数上是匹配的。这说明现有的构造已经接近最优，没有太大的改进空间了。</li>
<li><strong>澄清了研究方向</strong>：这个结果促使研究人员去探索其他方向，比如稍微放宽MSR码的限制（例如，允许修复带宽比理论最小值多一点点），来换取更小的子包化率。</li>
</ol>
<hr>
<h3 id="第二部分：主要结果的推导过程"><a href="#第二部分：主要结果的推导过程" class="headerlink" title="第二部分：主要结果的推导过程"></a>第二部分：主要结果的推导过程</h3><p>论文的证明非常巧妙，它将一个复杂的编码理论问题，通过一系列步骤，转化为了一个纯粹的、更易于分析的线性代数问题。</p>
<h4 id="步骤-1：将修复问题代数化-Algebraic-Setup"><a href="#步骤-1：将修复问题代数化-Algebraic-Setup" class="headerlink" title="步骤 1：将修复问题代数化 (Algebraic Setup)"></a>步骤 1：将修复问题代数化 (Algebraic Setup)</h4><p>假设一个 <code>(n, k, l)</code>-MSR码，<code>r = n-k</code>。我们要修复第 <code>m</code> 个节点 (<code>c_m</code>)。</p>
<ol>
<li><p><strong>恢复条件</strong>：为了完全恢复 <code>c_m</code> (一个 <code>l</code> 维向量)，我们需要从其他节点收集足够的信息。从第 <code>k+i</code> 个校验节点发送的信息中，与 <code>c_m</code> 相关部分可以表示为 <code>S_&#123;i,m&#125;C_&#123;i,m&#125;c_m</code>，其中 <code>S_&#123;i,m&#125;</code> 是修复矩阵，<code>C_&#123;i,m&#125;</code> 是编码矩阵。为了恢复 <code>c_m</code>，所有这些信息的行空间（row span）必须能张成整个 <code>l</code> 维空间 <code>F^l</code>。</p>
<blockquote>
<p><strong>公式 (3)</strong>：<br>$$ \bigoplus_{i&#x3D;1}^{r} \mathcal{R}(S_{i,m}C_{i,m}) &#x3D; \mathbb{F}^l $$<br>这里的 <code>⊕</code> 表示直和，意味着这些空间的基向量是线性无关的。</p>
</blockquote>
</li>
<li><p><strong>干扰消除 (Interference Cancellation)</strong>：校验节点发送的信息中，不仅包含 <code>c_m</code> 的信息，还包含其他节点 <code>c_&#123;m&#39;&#125;</code> (<code>m&#39; ≠ m</code>) 的信息，这部分是“干扰”。为了高效修复，所有 <code>r</code> 个校验节点发来的关于 <code>c_&#123;m&#39;&#125;</code> 的干扰信息，必须都处在一个共同的、低维的子空间里，这样才能被系统中的其他节点有效地抵消掉。</p>
<blockquote>
<p><strong>公式 (5)</strong>：<br>$$ \mathcal{R}(S_{1,m}C_{1,m’}) &#x3D; \mathcal{R}(S_{2,m}C_{2,m’}) &#x3D; \dots &#x3D; \mathcal{R}(S_{r,m}C_{r,m’}) $$<br>这意味着对于任意一个干扰源 <code>c_&#123;m&#39;&#125;</code>，来自不同校验节点的干扰信号的行空间是完全相同的。</p>
</blockquote>
</li>
</ol>
<h4 id="步骤-2：转化为MSR子空间族问题-Reduction-to-MSR-Subspace-Family"><a href="#步骤-2：转化为MSR子空间族问题-Reduction-to-MSR-Subspace-Family" class="headerlink" title="步骤 2：转化为MSR子空间族问题 (Reduction to MSR Subspace Family)"></a>步骤 2：转化为MSR子空间族问题 (Reduction to MSR Subspace Family)</h4><p>论文将上述代数条件抽象成一个关于子空间和线性变换的问题。</p>
<ul>
<li>定义一个 <code>l/r</code> 维的子空间 <code>H_i</code>，它代表修复第 <code>i</code> 个节点时所需的核心信息结构。</li>
<li>定义一组可逆线性变换 <code>Φ_&#123;i,j&#125;</code>，它由编码矩阵 <code>C</code> 决定。</li>
</ul>
<p>这样，上述的恢复条件和干扰消除条件可以被重新表述为对这些子空间 <code>H_i</code> 和变换 <code>Φ_&#123;i,j&#125;</code> 的要求。</p>
<blockquote>
<p><strong>定义 2 (MSR Subspace Family)</strong>：<br>一组 <code>l/r</code> 维的子空间 <code>&#123;H_1, H_2, ..., H_k&#125;</code> 构成一个MSR子空间族，如果存在一组线性变换 <code>Φ_&#123;i,j&#125;</code>，使得对每个 <code>i ∈ [k]</code>：</p>
<ol>
<li><strong>恢复条件</strong>: <code>H_i</code> 和它经过 <code>r-1</code> 个不同变换 <code>Φ_&#123;i,j&#125;</code> 后的像 <code>Φ_&#123;i,j&#125;(H_i)</code>，它们的直和可以张成整个空间 <code>F^l</code>。<blockquote>
<p><strong>公式 (6)</strong>: $$ H_i \oplus \bigoplus_{j&#x3D;1}^{r-1} \Phi_{i,j}(H_i) &#x3D; \mathbb{F}^l $$</p>
</blockquote>
</li>
<li><strong>干扰消除&#x2F;不变性条件</strong>: 与修复节点 <code>i&#39;</code> (<code>i&#39; ≠ i</code>) 相关的变换 <code>Φ_&#123;i&#39;,j&#125;</code>，作用在 <code>H_i</code> 上时，会使 <code>H_i</code> 保持不变。<blockquote>
<p><strong>公式 (7)</strong>: $$ \Phi_{i’,j}(H_i) &#x3D; H_i \quad \text{for every } j \in [r-1], \text{ and } i’ \neq i $$</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>论文引用前人工作指出，一个 <code>(n,k,l)</code>-MSR 码的存在，就意味着存在一个包含 <code>k-1</code> 个子空间的MSR子空间族。因此，<strong>只要我们能证明MSR子空间族的数量 <code>k-1</code> 有上限，就能得到 <code>l</code> 的下限</strong>。</p>
<h4 id="步骤-3：核心证明-维度衰减论证-The-Core-Proof"><a href="#步骤-3：核心证明-维度衰减论证-The-Core-Proof" class="headerlink" title="步骤 3：核心证明 - 维度衰减论证 (The Core Proof)"></a>步骤 3：核心证明 - 维度衰减论证 (The Core Proof)</h4><p>这是论文最精彩的部分，其灵感来自于伽罗瓦理论（Galois Theory）。</p>
<ol>
<li><p><strong>定义“不变性空间”</strong>：</p>
<blockquote>
<p><strong>定义 3</strong>: 对于一组子空间 <code>&#123;A_1, ..., A_s&#125;</code>，定义 <code>F(A_1, ..., A_s)</code> 为所有那些能使这组子空间都保持不变的线性变换 <code>γ</code> 的集合（即对所有 <code>i</code>，都有 <code>γ(A_i) ⊆ A_i</code>）。</p>
<p>定义 <code>I(A_1, ..., A_s)</code> 为这个线性变换集合 <code>F(...)</code> 的<strong>维度</strong>。</p>
</blockquote>
</li>
<li><p><strong>关键引理 (Lemma 5)</strong>：<br>这个引理是证明的核心。它表明，每当我们在不变性空间的集合中增加一个新的MSR子空间 <code>H_t</code>，这个空间的维度 <code>I(...)</code> 就会<strong>以一个固定的比例衰减</strong>。</p>
<blockquote>
<p><strong>引理 5 公式</strong>:<br>$$ I(H_1, \dots, H_t) \le \left(\frac{2r-1}{2r}\right) I(H_1, \dots, H_{t-1}) $$<br>这里的比例因子 <code>(2r-1)/(2r)</code> 是小于 1 的，所以维度在指数级下降。</p>
</blockquote>
</li>
<li><p><strong>最终推导</strong>：</p>
<ul>
<li><p>我们有一个包含 <code>k-1</code> 个子空间的MSR子空间族 <code>&#123;H_1, ..., H_&#123;k-1&#125;&#125;</code>。</p>
</li>
<li><p>初始时，不要求任何子空间不变，<code>I()</code> 就是所有 <code>l × l</code> 矩阵空间的维度，即 <code>l^2</code>。</p>
</li>
<li><p>每增加一个 <code>H_i</code>，维度就乘以一个小于1的因子。经过 <code>k-1</code> 次迭代后：<br>$$ I(H_1, \dots, H_{k-1}) \le l^2 \cdot \left(\frac{2r-1}{2r}\right)^{k-1} $$</p>
</li>
<li><p>我们知道，单位矩阵（Identity matrix）总是在这个不变性空间里（它让所有子空间都不变），所以这个空间的维度 <code>I(...)</code> 至少是 1。<br>$$ 1 \le I(H_1, \dots, H_{k-1}) $$</p>
</li>
<li><p>将两个不等式结合：<br>$$ 1 \le l^2 \cdot \left(\frac{2r-1}{2r}\right)^{k-1} $$</p>
</li>
<li><p>对这个不等式两边取对数并整理，就可以解出 <code>k</code> 的上限：<br>$$ (k-1) \ln\left(\frac{2r}{2r-1}\right) \le 2 \ln(l) $$</p>
</li>
<li><p>利用近似 <code>ln(1+x) ≈ x</code>（当 <code>x</code> 很小时），我们有 <code>ln(2r/(2r-1)) = ln(1 + 1/(2r-1)) ≈ 1/(2r-1)</code>。<br>$$ (k-1) \cdot \frac{1}{2r-1} \lesssim 2 \ln(l) \implies k-1 \lesssim 2(2r-1) \ln(l) \approx 4r \ln(l) $$<br>即 <code>k = O(r log l)</code>。</p>
</li>
<li><p>反过来，这个公式就给出了 <code>l</code> 的下限：<br>$$ \ln(l) \gtrsim \frac{k-1}{4r} \implies l \gtrsim \exp\left(\frac{k-1}{4r}\right) $$<br>这就是论文的核心结果 <code>l &gt; exp(Ω(k/r))</code>。</p>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：该论文通过一个优雅的数学推导，将编码修复问题转化为线性代数中的子空间不变性问题，并利用一个巧妙的维度衰减参数，证明了任何MSR码都无法逃脱子包化率指数增长的“宿命”。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">煊</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/06/09/MSRcode/">http://example.com/2025/06/09/MSRcode/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">鱼鱼煊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/">编码理论</a><a class="post-meta__tags" href="/tags/MSR/">MSR</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">煊</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fishxua"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">胡思乱想</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E8%AE%BA%E6%96%87%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9%E5%92%8C%E8%B4%A1%E7%8C%AE"><span class="toc-number">1.</span> <span class="toc-text">第一部分：论文主要内容和贡献</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E2%80%9C%E4%BF%AE%E5%A4%8D%E2%80%9D%E9%9A%BE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">1. 背景：分布式存储系统中的“修复”难题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98%EF%BC%9AMSR%E7%A0%81%E7%9A%84%E4%BB%A3%E4%BB%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2. 核心问题：MSR码的代价是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AE%BA%E6%96%87%E7%9A%84%E4%B8%BB%E8%A6%81%E8%B4%A1%E7%8C%AE"><span class="toc-number">1.3.</span> <span class="toc-text">3. 论文的主要贡献</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%9C%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">第二部分：主要结果的推导过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E5%B0%86%E4%BF%AE%E5%A4%8D%E9%97%AE%E9%A2%98%E4%BB%A3%E6%95%B0%E5%8C%96-Algebraic-Setup"><span class="toc-number">2.1.</span> <span class="toc-text">步骤 1：将修复问题代数化 (Algebraic Setup)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E8%BD%AC%E5%8C%96%E4%B8%BAMSR%E5%AD%90%E7%A9%BA%E9%97%B4%E6%97%8F%E9%97%AE%E9%A2%98-Reduction-to-MSR-Subspace-Family"><span class="toc-number">2.2.</span> <span class="toc-text">步骤 2：转化为MSR子空间族问题 (Reduction to MSR Subspace Family)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E6%A0%B8%E5%BF%83%E8%AF%81%E6%98%8E-%E7%BB%B4%E5%BA%A6%E8%A1%B0%E5%87%8F%E8%AE%BA%E8%AF%81-The-Core-Proof"><span class="toc-number">2.3.</span> <span class="toc-text">步骤 3：核心证明 - 维度衰减论证 (The Core Proof)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/09/MSRcode/" title="MSR编码子包化率的指数下界">MSR编码子包化率的指数下界</a><time datetime="2025-06-09T06:28:07.244Z" title="发表于 2025-06-09 14:28:07">2025-06-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By 煊</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>